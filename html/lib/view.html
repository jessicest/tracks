import { make_cell_id, make_hints, make_link_id } from './grid.js';
import { make_grid_state, parse_code } from './grid_state.js';
import { RuleReducer, SetStatus } from './rule_reducer.js';
class Painter {
}
export class View {
    constructor(canvas) {
        this.canvas = canvas;
        this.cell_radius = 1;
        this.link_radius = 1;
        this.paused = true;
        canvas.addEventListener('click', (event) => {
            this.click(true, this.event_pos(event));
            event.preventDefault();
            this.redraw();
            return false;
        });
        canvas.addEventListener('contextmenu', (event) => {
            this.click(false, this.event_pos(event));
            event.preventDefault();
            this.redraw();
            return false;
        });
        this.set_grid_state(make_grid_state(4, 4, [
            { pos: { x: 1, y: 1 }, direction: 1 },
            { pos: { x: 0, y: 2 }, direction: 0 },
            { pos: { x: 1, y: 4 }, direction: 0 },
            { pos: { x: 2, y: 4 }, direction: 1 }
        ], make_hints([4, 3, 3, 2], [4, 3, 3, 2])));
        window.addEventListener('resize', window.view.resize_canvas, false);
    }
    resize_canvas() {
        this.link_radius = 400 / (3 * Math.min(this.grid.xmax, this.grid.ymax) + 9);
        this.cell_radius = this.link_radius * 2;
        const cell_diameter = this.cell_radius * 2;
        const link_diameter = this.link_radius * 2;
        this.canvas.width = this.grid.xmax * (cell_diameter + link_diameter) + this.link_radius * 5 + this.cell_radius * 2;
        this.canvas.height = this.grid.ymax * (cell_diameter + link_diameter) + this.link_radius * 5 + this.cell_radius * 2;
    }
    set_grid_state(grid_state) {
        this.grid = grid_state.grid;
        this.grid_state = grid_state;
        this.rule_reducer = new RuleReducer(grid_state, new Set(), new Map(), true);
        this.rule_reducer.initialize();
        this.resize_canvas();
        this.redraw();
    }
    event_pos(event) {
        return { x: event.offsetX, y: event.offsetY };
    }
    click(left_click, pixel_pos) {
        const cell_diameter = this.cell_radius * 2;
        const link_diameter = this.link_radius * 2;
        const diameter = cell_diameter + link_diameter;
        const px = pixel_pos.x;
        const py = pixel_pos.y;
        const x_in_link = px % diameter > cell_diameter;
        const y_in_link = py % diameter > cell_diameter;
        const x = Math.floor(px / diameter);
        const y = Math.floor(py / diameter);
        let id = null;
        let is_link = true;
        if (!x_in_link && !y_in_link) {
            id = make_cell_id({ x, y });
            is_link = false;
        }
        else if (x_in_link && !y_in_link) {
            id = make_link_id({ x, y }, 0);
        }
        else if (!x_in_link && y_in_link) {
            id = make_link_id({ x, y }, 1);
        }
        if (id != null) {
            const status = this.grid_state.statuses.get(id);
            let new_status;
            if (left_click && status == 0) {
                new_status = 1;
            }
            else if (left_click && status == 1) {
                new_status = 0;
            }
            else if (!left_click && status == 2) {
                new_status = 1;
            }
            else if (!left_click && status == 1) {
                new_status = 2;
            }
            if (new_status != null) {
                if (is_link) {
                    this.execute(new SetStatus(this.rule_reducer, this.grid_state.grid.links.get(id).node, new_status, "click"), true);
                }
                else {
                    this.execute(new SetStatus(this.rule_reducer, this.grid_state.grid.cells.get(id).node, new_status, "click"), true);
                }
            }
        }
    }
    execute(action, paint) {
        const modified_ids = action.execute().slice();
        const next_candidate = this.rule_reducer.next_candidate();
        if (next_candidate != null) {
            modified_ids.push(next_candidate);
        }
        if (paint) {
            this.redraw_selection(modified_ids);
        }
    }
    get_state(id) {
        const status = this.grid_state.statuses.get(id);
        const is_candidate = this.rule_reducer.candidates.has(id);
        const is_next_candidate = (id == this.rule_reducer.next_candidate());
        return [status, is_candidate, is_next_candidate];
    }
    redraw() {
        const context = this.canvas.getContext("2d");
        context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for (const hint of this.grid.hints.values()) {
            this.draw_hint(context, hint);
        }
        for (const cell of this.grid.cells.values()) {
            this.draw_cell(context, cell);
        }
        for (const link of this.grid.links.values()) {
            this.draw_link(context, link);
        }
    }
    redraw_selection(ids) {
        const context = this.canvas.getContext("2d");
        for (const id of ids) {
            const hint = this.grid.hints.get(id);
            if (hint != null) {
                this.draw_hint(context, hint);
            }
            const cell = this.grid.cells.get(id);
            if (cell != null) {
                this.draw_cell(context, cell);
            }
            const link = this.grid.links.get(id);
            if (link != null) {
                this.draw_link(context, link);
            }
        }
    }
    draw_hint(context, hint) {
        const cell_diameter = this.cell_radius * 2;
        const link_diameter = this.link_radius * 2;
        const px = (hint.direction == 0)
            ? 0
            : hint.index * (cell_diameter + link_diameter);
        const py = (hint.direction == 1)
            ? 0
            : hint.index * (cell_diameter + link_diameter);
        const [_status, is_candidate, is_next_candidate] = this.get_state(hint.node.id);
        const num_cells = hint.node.cells.length;
        const [live_cells, unknown_cells] = this.grid_state.split_cells(hint.node.cells);
        let text_color = '#000000';
        let inner_color = '#ffffff';
        let outer_color = '#ffffff';
        if (live_cells.length + unknown_cells.length < hint.value) {
            text_color = '#aa0000';
        }
        else if (live_cells.length > hint.value) {
            text_color = '#aa0000';
        }
        else {
            if (is_next_candidate) {
                inner_color = '#ffaa22';
            }
            else if (is_candidate) {
                inner_color = '#00aa22';
            }
            if (live_cells.length == hint.value && unknown_cells.length == 0) {
                text_color = '#999999';
            }
        }
        this.draw_gradient(context, px, py, this.cell_radius, this.cell_radius, inner_color, outer_color);
        this.draw_text(context, px + this.cell_radius, py + this.cell_radius, hint.value.toString(), text_color);
    }
    draw_gradient(context, px, py, cx, cy, inner_color, outer_color) {
        const gradient = context.createRadialGradient(px + cx, py + cy, 1, px + cx, py + cy, Math.min(cx, cy));
        gradient.addColorStop(0, inner_color);
        gradient.addColorStop(1, outer_color);
        context.fillStyle = gradient;
        context.fillRect(px, py, cx * 2, cy * 2);
    }
    draw_text(context, px, py, value, color) {
        context.font = '20px Tahoma';
        context.fillStyle = color;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(value, px, py);
    }
    draw_line(context, px1, py1, px2, py2, color) {
        context.strokeStyle = color;
        context.lineWidth = 3;
        context.beginPath();
        context.moveTo(px1, py1);
        context.lineTo(px2, py2);
        context.stroke();
    }
    draw_cell(context, cell) {
        const cell_diameter = this.cell_radius * 2;
        const link_diameter = this.link_radius * 2;
        const x = cell.pos.x;
        const y = cell.pos.y;
        const px = x * (cell_diameter + link_diameter);
        const py = y * (cell_diameter + link_diameter);
        const [status, is_candidate, is_next_candidate] = this.get_state(cell.node.id);
        let inner_color, outer_color;
        if (status == 2) {
            inner_color = "#ddeeff";
        }
        else if (is_next_candidate) {
            inner_color = "#ffaa22";
        }
        else if (is_candidate) {
            inner_color = "#00aa22";
        }
        else {
            inner_color = "#8899dd";
        }
        if (status != 0) {
            outer_color = "#ddeeff";
        }
        else {
            outer_color = "#8899dd";
        }
        this.draw_gradient(context, px, py, this.cell_radius, this.cell_radius, inner_color, outer_color);
    }
    draw_link(context, link) {
        const cell_diameter = this.cell_radius * 2;
        const link_diameter = this.link_radius * 2;
        const x = link.pos.x;
        const y = link.pos.y;
        const direction = link.direction;
        let px, py, cx, cy, gap;
        if (direction == 1) {
            px = x * (cell_diameter + link_diameter);
            py = y * (cell_diameter + link_diameter) + cell_diameter;
            cx = this.cell_radius;
            cy = this.link_radius;
            gap = cx / 2;
        }
        else {
            px = x * (cell_diameter + link_diameter) + cell_diameter;
            py = y * (cell_diameter + link_diameter);
            cx = this.link_radius;
            cy = this.cell_radius;
            gap = cy / 2;
        }
        const [status, is_candidate, is_next_candidate] = this.get_state(link.node.id);
        let inner_color, outer_color;
        if (status == 2) {
            inner_color = "#ffeedd";
        }
        else if (is_next_candidate) {
            inner_color = "#ffaa22";
        }
        else if (is_candidate) {
            inner_color = "#00aa22";
        }
        else {
            inner_color = "#dd9988";
        }
        if (status != 0) {
            outer_color = "#ffeedd";
        }
        else {
            outer_color = "#dd9988";
        }
        this.draw_gradient(context, px, py, cx, cy, inner_color, outer_color);
        for (const cell of link.node.cells) {
        }
    }
    draw_chains(context, chains, cardinal, px, py, cx, cy, gap, color) {
        switch (cardinal) {
            case 0: {
                this.draw_line(context, px + cx, py + cy - gap, px, py + cy - gap, color);
                this.draw_line(context, px + cx, py + cy + gap, px, py + cy + gap, color);
                break;
            }
            case 1: {
                this.draw_line(context, px + cx, py + cy - gap, px + cx + cx, py + cy - gap, color);
                this.draw_line(context, px + cx, py + cy + gap, px + cx + cx, py + cy + gap, color);
                break;
            }
            case 2: {
                this.draw_line(context, px + cx - gap, py, px + cx - gap, py + cy, color);
                this.draw_line(context, px + cx + gap, py, px + cx + gap, py + cy, color);
                break;
            }
            case 3: {
                this.draw_line(context, px + cx - gap, py + cy + cy, px + cx - gap, py + cy, color);
                this.draw_line(context, px + cx + gap, py + cy + cy, px + cx + gap, py + cy, color);
                break;
            }
            default: throw "hm.";
        }
    }
    solve_step(paint) {
        const action = this.rule_reducer.process();
        if (action) {
            this.execute(action, paint);
            return true;
        }
        else {
            return false;
        }
    }
    auto_solve_step() {
        let next_frame_time = 0;
        function step(timestamp) {
            if (window.view.paused) {
                return;
            }
            if (timestamp >= next_frame_time) {
                const solve_rate = parseInt(document.getElementById('solve_rate').value);
                next_frame_time = timestamp + (1000 / 60);
                for (let i = 0; i < solve_rate; ++i) {
                    if (performance.now() >= next_frame_time) {
                        break;
                    }
                    if (!window.view.solve_step(true)) {
                        window.view.auto_solve_stop();
                        next_frame_time = 0;
                        return false;
                    }
                }
            }
            window.requestAnimationFrame(step);
        }
        window.requestAnimationFrame(step);
    }
    auto_solve_start() {
        window.view.paused = false;
        const button = document.getElementById('auto');
        button.innerHTML = 'stop';
        button.onclick = window.view.auto_solve_stop;
        window.view.auto_solve_step();
    }
    auto_solve_stop() {
        window.view.paused = true;
        const button = document.getElementById('auto');
        button.innerHTML = 'start';
        button.onclick = window.view.auto_solve_start;
        window.view.redraw();
    }
    parse() {
        window.view.auto_solve_stop();
        const code = document.getElementById('code').value;
        this.set_grid_state(parse_code(code));
    }
}
const canvas = document.getElementById('canvas');
window.view = new View(canvas);
